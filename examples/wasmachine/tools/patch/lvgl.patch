diff --git a/env_support/cmake/esp.cmake b/env_support/cmake/esp.cmake
index edc370991..7c897abed 100644
--- a/env_support/cmake/esp.cmake
+++ b/env_support/cmake/esp.cmake
@@ -11,7 +11,8 @@ if(LV_MICROPYTHON)
     ${LVGL_ROOT_DIR}/src
     ${LVGL_ROOT_DIR}/../
     REQUIRES
-    main)
+    main
+    wasm-micro-runtime)
 else()
   if(CONFIG_LV_BUILD_EXAMPLES)
     file(GLOB_RECURSE EXAMPLE_SOURCES ${LVGL_ROOT_DIR}/examples/*.c)
@@ -43,7 +44,7 @@ else()
   idf_component_register(SRCS ${SOURCES} ${EXAMPLE_SOURCES} ${DEMO_SOURCES}
       INCLUDE_DIRS ${LVGL_ROOT_DIR} ${LVGL_ROOT_DIR}/src ${LVGL_ROOT_DIR}/../
                    ${LVGL_ROOT_DIR}/examples ${LVGL_ROOT_DIR}/demos
-      REQUIRES esp_timer)
+      REQUIRES esp_timer wasm-micro-runtime)
 endif()
 
 target_compile_definitions(${COMPONENT_LIB} PUBLIC "-DLV_CONF_INCLUDE_SIMPLE")
diff --git a/lvgl.h b/lvgl.h
index 72be09d46..9211a4170 100644
--- a/lvgl.h
+++ b/lvgl.h
@@ -60,6 +60,7 @@ extern "C" {
 #include "src/widgets/lv_switch.h"
 
 #include "src/draw/lv_draw.h"
+#include "src/draw/sw/lv_draw_sw.h"
 
 #include "src/lv_api_map.h"
 
diff --git a/src/core/lv_event.c b/src/core/lv_event.c
index 1ca967210..46180402e 100644
--- a/src/core/lv_event.c
+++ b/src/core/lv_event.c
@@ -17,11 +17,6 @@
 /**********************
  *      TYPEDEFS
  **********************/
-typedef struct _lv_event_dsc_t {
-    lv_event_cb_t cb;
-    void * user_data;
-    lv_event_code_t filter : 8;
-} lv_event_dsc_t;
 
 /**********************
  *  STATIC PROTOTYPES
@@ -168,6 +163,7 @@ struct _lv_event_dsc_t * lv_obj_add_event_cb(lv_obj_t * obj, lv_event_cb_t event
     obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].cb = event_cb;
     obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].filter = filter;
     obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].user_data = user_data;
+    obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1].module_inst = NULL;
 
     return &obj->spec_attr->event_dsc[obj->spec_attr->event_dsc_cnt - 1];
 }
@@ -438,7 +434,13 @@ static lv_res_t event_send_core(lv_event_t * e)
            && (event_dsc->filter == (LV_EVENT_ALL | LV_EVENT_PREPROCESS) ||
                (event_dsc->filter & ~LV_EVENT_PREPROCESS) == e->code)) {
             e->user_data = event_dsc->user_data;
-            event_dsc->cb(e);
+
+            if (event_dsc->module_inst) {
+                uint32_t argv[1] = {(uint32_t)e};
+                lv_run_wasm(event_dsc->module_inst, event_dsc->cb, 1, argv);
+            } else {
+                event_dsc->cb(e);
+            }
 
             if(e->stop_processing) return LV_RES_OK;
             /*Stop if the object is deleted*/
@@ -458,7 +460,13 @@ static lv_res_t event_send_core(lv_event_t * e)
         if(event_dsc->cb && ((event_dsc->filter & LV_EVENT_PREPROCESS) == 0)
            && (event_dsc->filter == LV_EVENT_ALL || event_dsc->filter == e->code)) {
             e->user_data = event_dsc->user_data;
-            event_dsc->cb(e);
+
+            if (event_dsc->module_inst) {
+                uint32_t argv[1] = {(uint32_t)e};
+                lv_run_wasm(event_dsc->module_inst, event_dsc->cb, 1, argv);
+            } else {
+                event_dsc->cb(e);
+            }
 
             if(e->stop_processing) return LV_RES_OK;
             /*Stop if the object is deleted*/
diff --git a/src/core/lv_event.h b/src/core/lv_event.h
index d89d438db..951402f9e 100644
--- a/src/core/lv_event.h
+++ b/src/core/lv_event.h
@@ -24,7 +24,6 @@ extern "C" {
  **********************/
 
 struct _lv_obj_t;
-struct _lv_event_dsc_t;
 
 /**
  * Type of event being sent to the object.
@@ -131,6 +130,14 @@ typedef struct {
     const lv_area_t * area;
 } lv_cover_check_info_t;
 
+typedef struct _lv_event_dsc_t {
+    lv_event_cb_t cb;
+    void * user_data;
+    lv_event_code_t filter : 8;
+
+    void *module_inst;
+} lv_event_dsc_t;
+
 /**********************
  * GLOBAL PROTOTYPES
  **********************/
diff --git a/src/core/lv_refr.c b/src/core/lv_refr.c
index 55dd32643..9eab06658 100644
--- a/src/core/lv_refr.c
+++ b/src/core/lv_refr.c
@@ -348,7 +348,17 @@ void _lv_disp_refr_timer(lv_timer_t * tmr)
 
         /*Call monitor cb if present*/
         if(disp_refr->driver->monitor_cb) {
-            disp_refr->driver->monitor_cb(disp_refr->driver, elaps, px_num);
+            if (disp_refr->driver->module_inst) {
+                uint32_t argv[3];
+
+                argv[0] = (uint32_t)disp_refr->driver;
+                argv[1] = (uint32_t)elaps;
+                argv[2] = px_num;
+
+                lv_run_wasm(disp_refr->driver->module_inst, disp_refr->driver->monitor_cb, 3, argv);     
+            } else {
+                disp_refr->driver->monitor_cb(disp_refr->driver, elaps, px_num);
+            }
         }
     }
 
diff --git a/src/draw/lv_img_buf.c b/src/draw/lv_img_buf.c
index 5ac1eadf5..c6353339e 100644
--- a/src/draw/lv_img_buf.c
+++ b/src/draw/lv_img_buf.c
@@ -38,10 +38,23 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+static void *wasm_map_ptr(const lv_img_dsc_t *dsc, const void *ptr)
+{
+    void *mapped_ptr;
+    if (dsc->module_inst) {
+        wasm_module_inst_t module_inst = (wasm_module_inst_t)dsc->module_inst;
+        mapped_ptr = addr_app_to_native((uint32_t)ptr);
+    } else {
+        mapped_ptr = (void *)ptr;
+    }
+
+    return mapped_ptr;
+}
+
 lv_color_t lv_img_buf_get_px_color(const lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)
 {
     lv_color_t p_color = lv_color_black();
-    uint8_t * buf_u8 = (uint8_t *)dsc->data;
+    uint8_t * buf_u8 = (uint8_t *)wasm_map_ptr(dsc, dsc->data);
 
     if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED ||
        dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA || dsc->header.cf == LV_IMG_CF_RGB565A8) {
@@ -99,7 +112,7 @@ lv_color_t lv_img_buf_get_px_color(const lv_img_dsc_t * dsc, lv_coord_t x, lv_co
 
 lv_opa_t lv_img_buf_get_px_alpha(const lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y)
 {
-    uint8_t * buf_u8 = (uint8_t *)dsc->data;
+    uint8_t * buf_u8 = (uint8_t *)wasm_map_ptr(dsc, dsc->data);
 
     if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {
         uint32_t px = dsc->header.w * y * LV_IMG_PX_SIZE_ALPHA_BYTE + x * LV_IMG_PX_SIZE_ALPHA_BYTE;
@@ -154,7 +167,7 @@ lv_opa_t lv_img_buf_get_px_alpha(const lv_img_dsc_t * dsc, lv_coord_t x, lv_coor
 
 void lv_img_buf_set_px_alpha(const lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)
 {
-    uint8_t * buf_u8 = (uint8_t *)dsc->data;
+    uint8_t * buf_u8 = (uint8_t *)wasm_map_ptr(dsc, dsc->data);
 
     if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {
         uint8_t px_size          = lv_img_cf_get_px_size(dsc->header.cf) >> 3;
@@ -205,7 +218,7 @@ void lv_img_buf_set_px_alpha(const lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t
 
 void lv_img_buf_set_px_color(const lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)
 {
-    uint8_t * buf_u8 = (uint8_t *)dsc->data;
+    uint8_t * buf_u8 = (uint8_t *)wasm_map_ptr(dsc, dsc->data);
 
     if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
         uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf) >> 3;
@@ -272,7 +285,7 @@ void lv_img_buf_set_palette(const lv_img_dsc_t * dsc, uint8_t id, lv_color_t c)
 
     lv_color32_t c32;
     c32.full      = lv_color_to32(c);
-    uint8_t * buf = (uint8_t *)dsc->data;
+    uint8_t * buf = (uint8_t *)wasm_map_ptr(dsc, dsc->data);
     lv_memcpy_small(&buf[id * sizeof(c32)], &c32, sizeof(c32));
 }
 
diff --git a/src/draw/lv_img_buf.h b/src/draw/lv_img_buf.h
index a315a85ae..4e715fad8 100644
--- a/src/draw/lv_img_buf.h
+++ b/src/draw/lv_img_buf.h
@@ -141,6 +141,7 @@ typedef struct {
     lv_img_header_t header; /**< A header describing the basics of the image*/
     uint32_t data_size;     /**< Size of the image in bytes*/
     const uint8_t * data;   /**< Pointer to the data of the image*/
+    void *module_inst;
 } lv_img_dsc_t;
 
 /**********************
diff --git a/src/draw/lv_img_decoder.c b/src/draw/lv_img_decoder.c
index 76aff5ec7..a947e7fc4 100644
--- a/src/draw/lv_img_decoder.c
+++ b/src/draw/lv_img_decoder.c
@@ -50,6 +50,27 @@ static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc,
  *   GLOBAL FUNCTIONS
  **********************/
 
+static void *wasm_map_ptr(const lv_img_dsc_t *dsc, const void *ptr)
+{
+    void *mapped_ptr;
+    bool is_psram = false;
+#if SOC_MMU_PER_EXT_MEM_TARGET
+    is_psram = ((uint32_t)ptr>= SOC_EXTRAM_LOW) && ((uint32_t)ptr < SOC_EXTRAM_HIGH);
+#endif
+
+    if (dsc->module_inst && !esp_ptr_in_dram(ptr) && !is_psram) {
+        wasm_module_inst_t module_inst = (wasm_module_inst_t)dsc->module_inst;
+        mapped_ptr = addr_app_to_native((uint32_t)ptr);
+        if (!mapped_ptr) {
+            mapped_ptr = (void *)ptr;
+        }
+    } else {
+        mapped_ptr = (void *)ptr;
+    }
+
+    return mapped_ptr;
+}
+
 /**
  * Initialize the image decoder module
  */
@@ -365,7 +386,8 @@ lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder
         if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
             /*In case of uncompressed formats the image stored in the ROM/RAM.
              *So simply give its pointer*/
-            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
+            lv_img_dsc_t *p_src = (lv_img_dsc_t *)dsc->src;
+            dsc->img_data = (const uint8_t *)wasm_map_ptr(p_src, p_src->data);
             return LV_RES_OK;
         }
         else {
@@ -392,7 +414,8 @@ lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder
         if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
             /*In case of uncompressed formats the image stored in the ROM/RAM.
              *So simply give its pointer*/
-            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
+            lv_img_dsc_t *p_src = (lv_img_dsc_t *)dsc->src;
+            dsc->img_data = (const uint8_t *)wasm_map_ptr(p_src, p_src->data);
             return LV_RES_OK;
         }
         else {
@@ -441,7 +464,8 @@ lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder
         }
         else {
             /*The palette begins in the beginning of the image data. Just point to it.*/
-            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
+            lv_img_dsc_t *p_src = (lv_img_dsc_t *)dsc->src;
+            lv_color32_t * palette_p = (lv_color32_t *)wasm_map_ptr(p_src, p_src->data);
 
             uint32_t i;
             for(i = 0; i < palette_size; i++) {
@@ -626,7 +650,7 @@ static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, l
     if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
         const lv_img_dsc_t * img_dsc = dsc->src;
 
-        data_tmp = img_dsc->data + ofs;
+        data_tmp = (const uint8_t *)wasm_map_ptr(img_dsc, img_dsc->data) + ofs;
     }
     else {
         lv_fs_seek(&user_data->f, ofs + 4, LV_FS_SEEK_SET); /*+4 to skip the header*/
@@ -693,7 +717,7 @@ static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc,
     const uint8_t * data_tmp = NULL;
     if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
         const lv_img_dsc_t * img_dsc = dsc->src;
-        data_tmp                     = img_dsc->data + ofs;
+        data_tmp                     = (const uint8_t *)wasm_map_ptr(img_dsc, img_dsc->data) + ofs;
     }
     else {
         lv_fs_seek(&user_data->f, ofs + 4, LV_FS_SEEK_SET); /*+4 to skip the header*/
diff --git a/src/draw/sw/lv_draw_sw_arc.c b/src/draw/sw/lv_draw_sw_arc.c
index 3ed62b6ef..e24ef2e24 100644
--- a/src/draw/sw/lv_draw_sw_arc.c
+++ b/src/draw/sw/lv_draw_sw_arc.c
@@ -96,7 +96,7 @@ void lv_draw_sw_arc(lv_draw_ctx_t * draw_ctx, const lv_draw_arc_dsc_t * dsc, con
 
     /*Create inner the mask*/
     int16_t mask_in_id = LV_MASK_ID_INV;
-    lv_draw_mask_radius_param_t mask_in_param;
+    lv_draw_mask_radius_param_t mask_in_param = { 0 };
     bool mask_in_param_valid = false;
     if(lv_area_get_width(&area_in) > 0 && lv_area_get_height(&area_in) > 0) {
         lv_draw_mask_radius_init(&mask_in_param, &area_in, LV_RADIUS_CIRCLE, true);
diff --git a/src/font/lv_font.c b/src/font/lv_font.c
index d4cc27e19..a47fea40b 100644
--- a/src/font/lv_font.c
+++ b/src/font/lv_font.c
@@ -8,6 +8,7 @@
  *********************/
 
 #include "lv_font.h"
+#include "lv_font_fmt_txt.h"
 #include "../misc/lv_utils.h"
 #include "../misc/lv_log.h"
 #include "../misc/lv_assert.h"
@@ -48,8 +49,25 @@
  */
 const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
 {
+    bool is_psram = false;
+#if SOC_MMU_PER_EXT_MEM_TARGET
+    is_psram = ((uint32_t)font_p->get_glyph_bitmap >= SOC_EXTRAM_LOW) && ((uint32_t)font_p->get_glyph_bitmap < SOC_EXTRAM_HIGH);
+#endif
     LV_ASSERT_NULL(font_p);
-    return font_p->get_glyph_bitmap(font_p, letter);
+    if (!font_p->get_glyph_bitmap) {
+        return lv_font_get_bitmap_fmt_txt(font_p, letter);
+    } else if (font_p->module_inst && !esp_ptr_executable(font_p->get_glyph_bitmap) && !is_psram) {
+        uint32_t argv[2];
+
+        argv[0] = (uint32_t)font_p;
+        argv[1] = letter;
+
+        lv_run_wasm(font_p->module_inst, font_p->get_glyph_bitmap, 2, argv);
+
+        return (const uint8_t *)argv[0];
+    } else {
+        return font_p->get_glyph_bitmap(font_p, letter);
+    }
 }
 
 /**
@@ -77,7 +95,27 @@ bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_o
     dsc_out->resolved_font = NULL;
 
     while(f) {
-        bool found = f->get_glyph_dsc(f, dsc_out, letter, letter_next);
+        bool found;
+        bool is_psram = false;
+#if SOC_MMU_PER_EXT_MEM_TARGET
+        is_psram = ((uint32_t)f->get_glyph_dsc >= SOC_EXTRAM_LOW) && ((uint32_t)f->get_glyph_dsc < SOC_EXTRAM_HIGH);
+#endif
+        if (!f->get_glyph_dsc) {
+            found = lv_font_get_glyph_dsc_fmt_txt(f, dsc_out, letter, letter_next);
+        } else if (f->module_inst && !esp_ptr_executable(f->get_glyph_dsc) && !is_psram) {
+            uint32_t argv[4];
+
+            argv[0] = (uint32_t)f;
+            argv[1] = (uint32_t)dsc_out;
+            argv[2] = letter;
+            argv[3] = letter_next;
+
+            lv_run_wasm(f->module_inst, f->get_glyph_dsc, 4, argv);
+            found = (bool)argv[0];
+        } else {
+            found = f->get_glyph_dsc(f, dsc_out, letter, letter_next);
+        }
+
         if(found) {
             if(!dsc_out->is_placeholder) {
                 dsc_out->resolved_font = f;
@@ -94,7 +132,25 @@ bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_o
 
 #if LV_USE_FONT_PLACEHOLDER
     if(placeholder_font != NULL) {
-        placeholder_font->get_glyph_dsc(placeholder_font, dsc_out, letter, letter_next);
+        bool is_psram = false;
+#if SOC_MMU_PER_EXT_MEM_TARGET
+        is_psram = ((uint32_t)placeholder_font->get_glyph_dsc >= SOC_EXTRAM_LOW) && ((uint32_t)placeholder_font->get_glyph_dsc < SOC_EXTRAM_HIGH);
+#endif
+        if (!placeholder_font->get_glyph_dsc) {
+            lv_font_get_glyph_dsc_fmt_txt(placeholder_font, dsc_out, letter, letter_next);
+        } else if (placeholder_font->module_inst && !esp_ptr_executable(placeholder_font->get_glyph_dsc) && !is_psram) {
+            uint32_t argv[4];
+
+            argv[0] = (uint32_t)placeholder_font;
+            argv[1] = (uint32_t)dsc_out;
+            argv[2] = letter;
+            argv[3] = letter_next;
+
+            lv_run_wasm(placeholder_font->module_inst, placeholder_font->get_glyph_dsc, 4, argv);
+        } else {
+            placeholder_font->get_glyph_dsc(placeholder_font, dsc_out, letter, letter_next);
+        }
+
         dsc_out->resolved_font = placeholder_font;
         return true;
     }
diff --git a/src/font/lv_font.h b/src/font/lv_font.h
index e3b670c87..269d9472f 100644
--- a/src/font/lv_font.h
+++ b/src/font/lv_font.h
@@ -81,6 +81,7 @@ typedef struct _lv_font_t {
 #if LV_USE_USER_DATA
     void * user_data;               /**< Custom user data for font.*/
 #endif
+    void *module_inst;
 } lv_font_t;
 
 /**********************
diff --git a/src/font/lv_font_fmt_txt.c b/src/font/lv_font_fmt_txt.c
index 78beafff5..d853ca472 100644
--- a/src/font/lv_font_fmt_txt.c
+++ b/src/font/lv_font_fmt_txt.c
@@ -36,6 +36,7 @@ static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t
 static int32_t unicode_list_compare(const void * ref, const void * element);
 static int32_t kern_pair_8_compare(const void * ref, const void * element);
 static int32_t kern_pair_16_compare(const void * ref, const void * element);
+static void *wasm_map_ptr(const lv_font_t * font, const void *ptr);
 
 #if LV_USE_FONT_COMPRESSED
     static void decompress(const uint8_t * in, uint8_t * out, lv_coord_t w, lv_coord_t h, uint8_t bpp, bool prefilter);
@@ -80,14 +81,15 @@ const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unic
 {
     if(unicode_letter == '\t') unicode_letter = ' ';
 
-    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
+    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)wasm_map_ptr(font, font->dsc);
     uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
     if(!gid) return NULL;
 
-    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
+    const lv_font_fmt_txt_glyph_dsc_t * gdsc = (const lv_font_fmt_txt_glyph_dsc_t *)wasm_map_ptr(font, &fdsc->glyph_dsc[gid]);
+    const uint8_t *p_glyph_bitmap = (const uint8_t *)wasm_map_ptr(font, fdsc->glyph_bitmap);
 
     if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
-        return &fdsc->glyph_bitmap[gdsc->bitmap_index];
+        return &p_glyph_bitmap[gdsc->bitmap_index];
     }
     /*Handle compressed bitmap*/
     else {
@@ -124,7 +126,7 @@ const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unic
         }
 
         bool prefilter = fdsc->bitmap_format == LV_FONT_FMT_TXT_COMPRESSED ? true : false;
-        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], LV_GC_ROOT(_lv_font_decompr_buf), gdsc->box_w, gdsc->box_h,
+        decompress(&p_glyph_bitmap[gdsc->bitmap_index], LV_GC_ROOT(_lv_font_decompr_buf), gdsc->box_w, gdsc->box_h,
                    (uint8_t)fdsc->bpp, prefilter);
         return LV_GC_ROOT(_lv_font_decompr_buf);
 #else /*!LV_USE_FONT_COMPRESSED*/
@@ -153,7 +155,7 @@ bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t *
     if(is_tab) {
         unicode_letter = ' ';
     }
-    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
+    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)wasm_map_ptr(font, font->dsc);
     uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
     if(!gid) return false;
 
@@ -166,7 +168,7 @@ bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t *
     }
 
     /*Put together a glyph dsc*/
-    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
+    const lv_font_fmt_txt_glyph_dsc_t * gdsc = (const lv_font_fmt_txt_glyph_dsc_t *)wasm_map_ptr(font, &fdsc->glyph_dsc[gid]);
 
     int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
 
@@ -206,62 +208,94 @@ void _lv_font_clean_up_fmt_txt(void)
  *   STATIC FUNCTIONS
  **********************/
 
+static void *wasm_map_ptr(const lv_font_t * font, const void *ptr)
+{
+    void *mapped_ptr;
+    bool is_psram = false;
+#if SOC_MMU_PER_EXT_MEM_TARGET
+    is_psram = ((uint32_t)ptr>= SOC_EXTRAM_LOW) && ((uint32_t)ptr < SOC_EXTRAM_HIGH);
+#endif
+
+    if (font->module_inst && !esp_ptr_in_dram(ptr) && !is_psram) {
+        wasm_module_inst_t module_inst = (wasm_module_inst_t)font->module_inst;
+        mapped_ptr = addr_app_to_native((uint32_t)ptr);
+        if (!mapped_ptr) {
+            mapped_ptr = (void *)ptr;
+        }
+    } else {
+        mapped_ptr = (void *)ptr;
+    }
+
+    return mapped_ptr;
+}
+
 static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
 {
     if(letter == '\0') return 0;
 
-    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
+    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)wasm_map_ptr(font, font->dsc);
+
+    lv_font_fmt_txt_glyph_cache_t * cache;
+    
+    if (fdsc->cache) {
+        cache = (lv_font_fmt_txt_glyph_cache_t *)wasm_map_ptr(font, fdsc->cache);
+    } else {
+        cache = NULL;
+    }
 
     /*Check the cache first*/
-    if(fdsc->cache && letter == fdsc->cache->last_letter) return fdsc->cache->last_glyph_id;
+    if(cache && letter == cache->last_letter) return cache->last_glyph_id;
 
     uint16_t i;
     for(i = 0; i < fdsc->cmap_num; i++) {
+        const lv_font_fmt_txt_cmap_t * cmaps = (const lv_font_fmt_txt_cmap_t *)wasm_map_ptr(font, fdsc->cmaps);
 
         /*Relative code point*/
-        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
-        if(rcp > fdsc->cmaps[i].range_length) continue;
+        uint32_t rcp = letter - cmaps[i].range_start;
+        if(rcp > cmaps[i].range_length) continue;
         uint32_t glyph_id = 0;
-        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
-            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
+        if(cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
+            glyph_id = cmaps[i].glyph_id_start + rcp;
         }
-        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
-            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
-            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
+        else if(cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
+            const uint8_t * gid_ofs_8 = cmaps[i].glyph_id_ofs_list;
+            glyph_id = cmaps[i].glyph_id_start + gid_ofs_8[rcp];
         }
-        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
+        else if(cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
             uint16_t key = rcp;
-            uint16_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
-                                             sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
+            uint16_t *unicode_list = (uint16_t *)wasm_map_ptr(font, cmaps[i].unicode_list);
+            uint16_t * p = _lv_utils_bsearch(&key, unicode_list, cmaps[i].list_length,
+                                             sizeof(unicode_list[0]), unicode_list_compare);
 
             if(p) {
-                lv_uintptr_t ofs = p - fdsc->cmaps[i].unicode_list;
-                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
+                lv_uintptr_t ofs = p - unicode_list;
+                glyph_id = cmaps[i].glyph_id_start + ofs;
             }
         }
-        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
+        else if(cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
             uint16_t key = rcp;
-            uint16_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
-                                             sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
+            uint16_t *unicode_list = (uint16_t *)wasm_map_ptr(font, cmaps[i].unicode_list);
+            uint16_t * p = _lv_utils_bsearch(&key, unicode_list, cmaps[i].list_length,
+                                             sizeof(unicode_list[0]), unicode_list_compare);
 
             if(p) {
-                lv_uintptr_t ofs = p - fdsc->cmaps[i].unicode_list;
-                const uint16_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
-                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
+                lv_uintptr_t ofs = p - unicode_list;
+                const uint16_t * gid_ofs_16 = cmaps[i].glyph_id_ofs_list;
+                glyph_id = cmaps[i].glyph_id_start + gid_ofs_16[ofs];
             }
         }
 
         /*Update the cache*/
-        if(fdsc->cache) {
-            fdsc->cache->last_letter = letter;
-            fdsc->cache->last_glyph_id = glyph_id;
+        if(cache) {
+            cache->last_letter = letter;
+            cache->last_glyph_id = glyph_id;
         }
         return glyph_id;
     }
 
-    if(fdsc->cache) {
-        fdsc->cache->last_letter = letter;
-        fdsc->cache->last_glyph_id = 0;
+    if(cache) {
+        cache->last_letter = letter;
+        cache->last_glyph_id = 0;
     }
     return 0;
 
@@ -269,37 +303,39 @@ static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
 
 static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
 {
-    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
+    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)wasm_map_ptr(font, font->dsc);
 
     int8_t value = 0;
 
     if(fdsc->kern_classes == 0) {
         /*Kern pairs*/
-        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
+        const lv_font_fmt_txt_kern_pair_t * kdsc = (const lv_font_fmt_txt_kern_pair_t *)wasm_map_ptr(font, fdsc->kern_dsc);
         if(kdsc->glyph_ids_size == 0) {
             /*Use binary search to find the kern value.
              *The pairs are ordered left_id first, then right_id secondly.*/
-            const uint16_t * g_ids = kdsc->glyph_ids;
+            const uint16_t * g_ids = wasm_map_ptr(font, kdsc->glyph_ids);
             uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
             uint16_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
 
             /*If the `g_id_both` were found get its index from the pointer*/
             if(kid_p) {
                 lv_uintptr_t ofs = kid_p - g_ids;
-                value = kdsc->values[ofs];
+                const uint8_t *p_value = (const uint8_t *)wasm_map_ptr(font, kdsc->values);
+                value = p_value[ofs];
             }
         }
         else if(kdsc->glyph_ids_size == 1) {
             /*Use binary search to find the kern value.
              *The pairs are ordered left_id first, then right_id secondly.*/
-            const uint32_t * g_ids = kdsc->glyph_ids;
+            const uint32_t * g_ids = (const uint32_t *)wasm_map_ptr(font, kdsc->glyph_ids);
             uint32_t g_id_both = (gid_right << 16) + gid_left; /*Create one number from the ids*/
             uint32_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
 
             /*If the `g_id_both` were found get its index from the pointer*/
             if(kid_p) {
                 lv_uintptr_t ofs = kid_p - g_ids;
-                value = kdsc->values[ofs];
+                const uint8_t *p_value = (const uint8_t *)wasm_map_ptr(font, kdsc->values);
+                value = p_value[ofs];
             }
 
         }
@@ -309,14 +345,14 @@ static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t
     }
     else {
         /*Kern classes*/
-        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
-        uint8_t left_class = kdsc->left_class_mapping[gid_left];
-        uint8_t right_class = kdsc->right_class_mapping[gid_right];
+        const lv_font_fmt_txt_kern_classes_t * kdsc = (const lv_font_fmt_txt_kern_classes_t *)wasm_map_ptr(font, fdsc->kern_dsc);
+        uint8_t left_class = ((const uint8_t *)wasm_map_ptr(font, kdsc->left_class_mapping))[gid_left];
+        uint8_t right_class = ((const uint8_t *)wasm_map_ptr(font, kdsc->right_class_mapping))[gid_right];
 
         /*If class = 0, kerning not exist for that glyph
          *else got the value form `class_pair_values` 2D array*/
         if(left_class > 0 && right_class > 0) {
-            value = kdsc->class_pair_values[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];
+            value = ((const uint8_t *)wasm_map_ptr(font, kdsc->class_pair_values))[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];
         }
 
     }
diff --git a/src/hal/lv_hal_disp.h b/src/hal/lv_hal_disp.h
index d942860e4..90d401fc9 100644
--- a/src/hal/lv_hal_disp.h
+++ b/src/hal/lv_hal_disp.h
@@ -149,6 +149,7 @@ typedef struct _lv_disp_drv_t {
     void * user_data; /**< Custom display driver user data*/
 #endif
 
+    void *module_inst;
 } lv_disp_drv_t;
 
 /**
diff --git a/src/lv_conf_internal.h b/src/lv_conf_internal.h
index 0c297081c..9951478a2 100644
--- a/src/lv_conf_internal.h
+++ b/src/lv_conf_internal.h
@@ -2533,4 +2533,12 @@ LV_EXPORT_CONST_INT(LV_DPI_DEF);
     #endif
 #endif  /*defined(LV_CONF_SKIP)*/
 
+#include "bh_platform.h"
+#include "wasm_export.h"
+#include "wasm_native.h"
+#include "wasm_runtime_common.h"
+#include "esp_memory_utils.h"
+
+void lv_run_wasm(void *module_inst, void *cb, int argc, uint32_t *argv);
+
 #endif  /*LV_CONF_INTERNAL_H*/
diff --git a/src/misc/lv_anim.c b/src/misc/lv_anim.c
index 9291cf498..7c8aacebf 100644
--- a/src/misc/lv_anim.c
+++ b/src/misc/lv_anim.c
@@ -97,12 +97,34 @@ lv_anim_t * lv_anim_start(const lv_anim_t * a)
     /*Set the start value*/
     if(new_anim->early_apply) {
         if(new_anim->get_value_cb) {
-            int32_t v_ofs = new_anim->get_value_cb(new_anim);
+            int32_t v_ofs;
+            if (new_anim->module_inst) {
+                uint32_t argv[1];
+
+                argv[0] = (uint32_t)new_anim;
+
+                lv_run_wasm(new_anim->module_inst, new_anim->get_value_cb, 1, argv);
+                v_ofs = (int32_t)argv[0];
+            } else {
+                v_ofs = new_anim->get_value_cb(new_anim);
+            }
+
             new_anim->start_value += v_ofs;
             new_anim->end_value += v_ofs;
         }
 
-        if(new_anim->exec_cb && new_anim->var) new_anim->exec_cb(new_anim->var, new_anim->start_value);
+        if(new_anim->exec_cb && new_anim->var) {
+            if (new_anim->module_inst) {
+                uint32_t argv[2];
+
+                argv[0] = (uint32_t)new_anim->var;
+                argv[1] = (uint32_t)new_anim->start_value;
+
+                lv_run_wasm(new_anim->module_inst, new_anim->exec_cb, 2, argv);
+            } else {
+                new_anim->exec_cb(new_anim->var, new_anim->start_value);
+            }
+        }
     }
 
     /*Creating an animation changed the linked list.
@@ -146,7 +168,18 @@ bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)
 
         if((a->var == var || var == NULL) && (a->exec_cb == exec_cb || exec_cb == NULL)) {
             _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);
-            if(a->deleted_cb != NULL) a->deleted_cb(a);
+            if(a->deleted_cb != NULL) {
+                if (a->module_inst) {
+                    uint32_t argv[1];
+
+                    argv[0] = (uint32_t)a;
+
+                    lv_run_wasm(a->module_inst,  a->deleted_cb, 1, argv);
+                } else {
+                    a->deleted_cb(a);
+                }
+            }
+
             lv_mem_free(a);
             anim_mark_list_change(); /*Read by `anim_timer`. It need to know if a delete occurred in
                                        the linked list*/
@@ -371,7 +404,18 @@ static void anim_timer(lv_timer_t * param)
             int32_t new_act_time = a->act_time + elaps;
             if(!a->start_cb_called && a->act_time <= 0 && new_act_time >= 0) {
                 if(a->early_apply == 0 && a->get_value_cb) {
-                    int32_t v_ofs = a->get_value_cb(a);
+                    int32_t v_ofs;
+                    if (a->module_inst) {
+                        uint32_t argv[1];
+
+                        argv[0] = (uint32_t)a;
+
+                        lv_run_wasm(a->module_inst, a->get_value_cb, 1, argv);
+                        v_ofs = (int32_t)argv[0];
+                    } else {
+                        v_ofs = a->get_value_cb(a);
+                    }
+
                     a->start_value += v_ofs;
                     a->end_value += v_ofs;
                 }
@@ -383,12 +427,36 @@ static void anim_timer(lv_timer_t * param)
                 if(a->act_time > a->time) a->act_time = a->time;
 
                 int32_t new_value;
-                new_value = a->path_cb(a);
+                bool is_psram = false;
+#if SOC_MMU_PER_EXT_MEM_TARGET
+                is_psram = ((uint32_t)a->path_cb >= SOC_EXTRAM_LOW) && ((uint32_t)a->path_cb < SOC_EXTRAM_HIGH);
+#endif
+                if (a->module_inst && !esp_ptr_executable(a->path_cb) && !is_psram) {
+                    uint32_t argv[1];
+
+                    argv[0] = (uint32_t)a;
+
+                    lv_run_wasm(a->module_inst, a->path_cb, 1, argv);
+                    new_value = (int32_t)argv[0];
+                } else {
+                    new_value = a->path_cb(a);
+                }
 
                 if(new_value != a->current_value) {
                     a->current_value = new_value;
                     /*Apply the calculated value*/
-                    if(a->exec_cb) a->exec_cb(a->var, new_value);
+                    if(a->exec_cb) {
+                        if (a->module_inst) {
+                            uint32_t argv[2];
+
+                            argv[0] = (uint32_t)a->var;
+                            argv[1] = (uint32_t)new_value;
+
+                            lv_run_wasm(a->module_inst, a->exec_cb, 2, argv);
+                        } else {
+                            a->exec_cb(a->var, new_value);
+                        }
+                    }
                 }
 
                 /*If the time is elapsed the animation is ready*/
@@ -433,8 +501,30 @@ static void anim_ready_handler(lv_anim_t * a)
         anim_mark_list_change();
 
         /*Call the callback function at the end*/
-        if(a->ready_cb != NULL) a->ready_cb(a);
-        if(a->deleted_cb != NULL) a->deleted_cb(a);
+        if(a->ready_cb != NULL) {
+            if (a->module_inst) {
+                uint32_t argv[1];
+
+                argv[0] = (uint32_t)a;
+
+                lv_run_wasm(a->module_inst, a->ready_cb, 1, argv);
+            } else {
+                a->ready_cb(a);
+            }
+        }
+
+        if(a->deleted_cb != NULL) {
+            if (a->module_inst) {
+                uint32_t argv[1];
+
+                argv[0] = (uint32_t)a;
+
+                lv_run_wasm(a->module_inst, a->deleted_cb, 1, argv);
+            } else {
+                a->deleted_cb(a);
+            }
+        }
+
         lv_mem_free(a);
     }
     /*If the animation is not deleted then restart it*/
diff --git a/src/misc/lv_anim.h b/src/misc/lv_anim.h
index faef72787..c3cb0b6d9 100644
--- a/src/misc/lv_anim.h
+++ b/src/misc/lv_anim.h
@@ -96,6 +96,8 @@ typedef struct _lv_anim_t {
     uint8_t playback_now : 1; /**< Play back is in progress*/
     uint8_t run_round : 1;    /**< Indicates the animation has run in this round*/
     uint8_t start_cb_called : 1;    /**< Indicates that the `start_cb` was already called*/
+
+    void *module_inst;
 } lv_anim_t;
 
 /**********************
diff --git a/src/misc/lv_anim_timeline.c b/src/misc/lv_anim_timeline.c
index 08d5321fb..387157b85 100644
--- a/src/misc/lv_anim_timeline.c
+++ b/src/misc/lv_anim_timeline.c
@@ -159,7 +159,18 @@ void lv_anim_timeline_set_progress(lv_anim_timeline_t * at, uint16_t progress)
             value = a->end_value;
         }
 
-        a->exec_cb(a->var, value);
+        if(a->exec_cb) {
+            if (a->module_inst) {
+                uint32_t argv[2];
+
+                argv[0] = (uint32_t)a->var;
+                argv[1] = (uint32_t)value;
+
+                lv_run_wasm(a->module_inst, a->exec_cb, 2, argv);
+            } else {
+                a->exec_cb(a->var, value);
+            }
+        }
     }
 }
 
diff --git a/src/misc/lv_timer.c b/src/misc/lv_timer.c
index a21038a36..5cb030b10 100644
--- a/src/misc/lv_timer.c
+++ b/src/misc/lv_timer.c
@@ -178,6 +178,7 @@ lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * us
     new_timer->paused = 0;
     new_timer->last_run = lv_tick_get();
     new_timer->user_data = user_data;
+    new_timer->module_inst = NULL;
 
     timer_created = true;
 
@@ -310,7 +311,15 @@ static bool lv_timer_exec(lv_timer_t * timer)
         if(timer->repeat_count > 0) timer->repeat_count--;
         timer->last_run = lv_tick_get();
         TIMER_TRACE("calling timer callback: %p", *((void **)&timer->timer_cb));
-        if(timer->timer_cb && original_repeat_count != 0) timer->timer_cb(timer);
+        if(timer->timer_cb && original_repeat_count != 0) {
+            if (timer->module_inst) {
+                uint32_t argv[1] = {(uint32_t)timer};
+
+                lv_run_wasm(timer->module_inst, timer->timer_cb, 1, argv);
+            } else {
+                timer->timer_cb(timer);
+            }
+        }
         TIMER_TRACE("timer callback %p finished", *((void **)&timer->timer_cb));
         LV_ASSERT_MEM_INTEGRITY();
         exec = true;
diff --git a/src/misc/lv_timer.h b/src/misc/lv_timer.h
index 50da8c9da..f94157838 100644
--- a/src/misc/lv_timer.h
+++ b/src/misc/lv_timer.h
@@ -48,6 +48,8 @@ typedef struct _lv_timer_t {
     void * user_data; /**< Custom user data*/
     int32_t repeat_count; /**< 1: One time;  -1 : infinity;  n>0: residual times*/
     uint32_t paused : 1;
+
+    void *module_inst;
 } lv_timer_t;
 
 /**********************
